Outline of class

Objects
-------
1. dictionary as pulled from YAML
   -- PRIVATE
2. list (or dictionary) of configuration keywords for variables with multiple
   possible default values
   -- PRIVATE
3. dictionary of varname / value pairs from input file
4. [Ordered] dictionary for varname / value pair (this_dict['varname'] = value
   -- PUBLIC
   -- varname should be what is seen in the input file (i.e. var_array(1) = val1)

Methods
-------

1. Constructor
   - INTENT(IN): YAML file name, input file name (or None), anything that needs
                 to be stored in object (2)
   i.   Set up object (2)
   ii.  Read YAML into object (1)
   iii. If present, read input file into object (3)
   iv.  Combine objects (1) and (3) into object (4)
       -- order matters! use category / subcategory / natural sorting

2. Get category names
   - PUBLIC
   - INTENT(IN): None
   - RETURN: the list in _order key of YAML file
   - consistency checks:
     i.   All keys in _order should also be in the YAML
     ii.  All keys in the YAML that don't begin with _ should be in _order
     iii. No duplicates in _order

3. Get subcategory names
   - PUBLIC
   - INTENT(IN): category name
   - RETURN: list of all subcategories in provided category

4. Get YAML variable names in a specific category
   - PUBLIC
   - INTENT(IN): category name
   - RETURN: list of all variables in provided category
   - NOTE: do not expand arrays (return "arr" rather than "arr(1), arr(2), ...")

5. Get all variable names
   - PUBLIC
   - INTENT(IN): subcategory name
   - RETURN: list of keys for Object (4) that are variables in provided subcategory
   - NOTES: make subcategory optional? Could just return a full list?
            optional sort key argument?

6. Process variable values
   - PRIVATE
   - PURPOSE: determine if variable is derived type or not, then call _update_parm_dict()
   - INTENT(IN): category name, variable name
   - RETURN: None

7. Update parm_dict
   - PRIVATE
   - PURPOSE: Populate Object (4) based on contents of (1) and (3)
              Arrays need to be expanded
   - INTENT(IN): variable dictionary, variable name, base name if element of derived type
   - RETURN: None

Module Functions / Subroutines
------------------------------

1. Abort
   - PRIVATE
   - Clean wrapper to sys.exit()

2. Get variable value
   - PRIVATE
   - If variable is in input file dict, return its value; otherwise return YAML value
   - Requires variable to be defined in YAML

3. Sort
   - PRIVATE
   - Wrapper for sorting lists, default is case-insensitive alphabetical but can take any key

4. Sort with specific suffix first
   - PRIVATE
   - In one case, we need to ensure that auto_ind_cnt and zoo_ind_cnt appear before auto_ind and zoo_ind

5. Natural Sort Key
   - PRIVATE
   - Sorts numbers in numeric order, so "word10" comes after "word9", not "word1"
   - Use as a key for Function (3)

6. Add increments
   - PRIVATE
   - Some values (such as tracer count) need to be adjusted depending on parameter values

7. Get dimension size
   - PRIVATE
   - Parses the "_array_size" key from YAML (can be integer value or refer to other YAML variable)

8. Get array info
   - PRIVATE
   - For arrays, return a list containing all the array indices, e.g. ["(1)", "(2)", ... ] for
     1D arrays or ["(1,1)", "(2,1)", ... ] for 2D arrays

9. String to Substring
   - PRIVATE
   - str.split(), unless the delimiter is inside quotes

10. Parse input file
   - PRIVATE
   - Read an input file line by line, return dictionary for each "varname = value" pair
   - Needs to recognize arrays, so "varname = 10, 20" -> "varname(1) = 10", "varname(2) = 20"
   - Ignore blank lines
   - Ignore comments

*****************************

YAML
----

1. Variables that are not a derived type look like

      category :
        variable_name :
          ...

   With the following required dictionary entries:
   - longname : string containing longname used as comment and in add_var call in Fortran
   - subcategory : string used for sorting purposes
   - units : units of the variable (non-numeric for strings / logical variables)
   - datatype : string, logical, real, or integer [use a dictionary for derived type; see below]
     - _array_size : defined if variable is actually an array [size can be integer or variable name]
     - _array_len_to_print : number of elements of array to include in input file [use _array_size if not specified]
     - _is_allocatable : indicate that autogenerated code should make this array allocatable [treat as False if not present]
   - default_value : value of appropriate type [use dictionary if providing multiple defaults]

2. Elements of derived type: same as above, except nested in datatype

      category :
        variable_name :
          datatype :
            element_name :
          ...

3. Optional variable sub-entries:
   - _append_to_config_keywords : this variable is used as a keyword in determining other variable default values
   - valid_values : List of allowable values => error if provided value is not in list
     (TODO at some point allow functions, like "this real variable must be non-negative")
   - cannot_change / must_set : Flags to indicate user must accept default value (or must specify a value in input file)
     (TODO this will be hard to implement, since current example will depend on PFT_defaults)